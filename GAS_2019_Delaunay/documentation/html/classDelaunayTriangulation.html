<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Delaunay_Project: DelaunayTriangulation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Delaunay_Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classDelaunayTriangulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DelaunayTriangulation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that manage the Delaunay Triangulation. The aim of this class is to build and fill all the data structures that rappresenting the triangulation. This class contains a vector of triangles that collect all that triangles made by splits; a dag node pointer used to build the DAG structure starting from the root (the bounding triangle); a vector of dagNode pointer that collect all the created pointer of the DAG (this is made to manage the cancellation of the dag and the construction of the voronoi diagram)  
 <a href="classDelaunayTriangulation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="delaunaytriangulation_8h_source.html">delaunaytriangulation.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for DelaunayTriangulation:</div>
<div class="dyncontent">
<div class="center"><img src="classDelaunayTriangulation__coll__graph.png" border="0" usemap="#DelaunayTriangulation_coll__map" alt="Collaboration graph"/></div>
<map name="DelaunayTriangulation_coll__map" id="DelaunayTriangulation_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa27c8ab9d568f35b3b47c0456bb45591"><td class="memItemLeft" align="right" valign="top"><a id="aa27c8ab9d568f35b3b47c0456bb45591"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#aa27c8ab9d568f35b3b47c0456bb45591">DelaunayTriangulation</a> ()</td></tr>
<tr class="memdesc:aa27c8ab9d568f35b3b47c0456bb45591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:aa27c8ab9d568f35b3b47c0456bb45591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7899c4090d9c578b0b92df9a9ae4ecaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a7899c4090d9c578b0b92df9a9ae4ecaf">DelaunayTriangulation</a> (const <a class="el" href="classTriangle.html">Triangle</a> &amp;boundingTriangle)</td></tr>
<tr class="memdesc:a7899c4090d9c578b0b92df9a9ae4ecaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using the bounding triangle's reference. Once the triangle is pushed inside the triangles vector, its index is used to instantiate the dag root.  <a href="#a7899c4090d9c578b0b92df9a9ae4ecaf">More...</a><br /></td></tr>
<tr class="separator:a7899c4090d9c578b0b92df9a9ae4ecaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e046be9eede34621f3d120deb8463ac"><td class="memItemLeft" align="right" valign="top"><a id="a1e046be9eede34621f3d120deb8463ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a1e046be9eede34621f3d120deb8463ac">~DelaunayTriangulation</a> ()</td></tr>
<tr class="memdesc:a1e046be9eede34621f3d120deb8463ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstructor. It calls the function clearDelaunayTriangulation in order to manage the cancellation of the data structures. <br /></td></tr>
<tr class="separator:a1e046be9eede34621f3d120deb8463ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b0689002927ddaecf48dab2b485037"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTriangle.html">Triangle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a52b0689002927ddaecf48dab2b485037">getTriangles</a> () const</td></tr>
<tr class="memdesc:a52b0689002927ddaecf48dab2b485037"><td class="mdescLeft">&#160;</td><td class="mdescRight">getTrianles get the reference to the vector of triangles  <a href="#a52b0689002927ddaecf48dab2b485037">More...</a><br /></td></tr>
<tr class="separator:a52b0689002927ddaecf48dab2b485037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3063d43c2871b7d2e610c16d8d30d84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#ae3063d43c2871b7d2e610c16d8d30d84">getDAG</a> () const</td></tr>
<tr class="memdesc:ae3063d43c2871b7d2e610c16d8d30d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">getDAG get the pointer to the dag root  <a href="#ae3063d43c2871b7d2e610c16d8d30d84">More...</a><br /></td></tr>
<tr class="separator:ae3063d43c2871b7d2e610c16d8d30d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f5d0fe187dd2709b3673af78ec738c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTriangle.html">Triangle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#ae5f5d0fe187dd2709b3673af78ec738c">getLeaves</a> () const</td></tr>
<tr class="memdesc:ae5f5d0fe187dd2709b3673af78ec738c"><td class="mdescLeft">&#160;</td><td class="mdescRight">getLeaves get the vector of triangles leaves.  <a href="#ae5f5d0fe187dd2709b3673af78ec738c">More...</a><br /></td></tr>
<tr class="separator:ae5f5d0fe187dd2709b3673af78ec738c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7cb250302b491e765c9de4b5c0f0d5"><td class="memItemLeft" align="right" valign="top">cg3::Point2Dd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a1c7cb250302b491e765c9de4b5c0f0d5">getOppositePoint</a> (const <a class="el" href="classTriangle.html">Triangle</a> &amp;currentTriangle, const <a class="el" href="classTriangle.html">Triangle</a> &amp;adjacentTriangle)</td></tr>
<tr class="memdesc:a1c7cb250302b491e765c9de4b5c0f0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">getOppositePoint get the point opposite the triangle under consideration.  <a href="#a1c7cb250302b491e765c9de4b5c0f0d5">More...</a><br /></td></tr>
<tr class="separator:a1c7cb250302b491e765c9de4b5c0f0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299f5ae7d5bbce0902ff8e05453ada94"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDagNode.html">DagNode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a299f5ae7d5bbce0902ff8e05453ada94">getAllDagNodes</a> ()</td></tr>
<tr class="memdesc:a299f5ae7d5bbce0902ff8e05453ada94"><td class="mdescLeft">&#160;</td><td class="mdescRight">getAllDagNodes get a reference to the vector of DAG nodes.  <a href="#a299f5ae7d5bbce0902ff8e05453ada94">More...</a><br /></td></tr>
<tr class="separator:a299f5ae7d5bbce0902ff8e05453ada94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d03a00c3df3a39981740142fb6d160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a51d03a00c3df3a39981740142fb6d160">getChildContainsPoint</a> (<a class="el" href="classDagNode.html">DagNode</a> *&amp;currentNode, const cg3::Point2Dd &amp;point)</td></tr>
<tr class="memdesc:a51d03a00c3df3a39981740142fb6d160"><td class="mdescLeft">&#160;</td><td class="mdescRight">getChildContainsPoint, given the current node and the new point to be inserted in the triangulation, return the children that cointains the point. scrolling through the list of children, it is checked which contains the node and is then returned.  <a href="#a51d03a00c3df3a39981740142fb6d160">More...</a><br /></td></tr>
<tr class="separator:a51d03a00c3df3a39981740142fb6d160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89a4e0a261185c9ed1c716d007c97c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#ac89a4e0a261185c9ed1c716d007c97c2">addTriangleToTriangulation</a> (const <a class="el" href="classTriangle.html">Triangle</a> &amp;newTriangle)</td></tr>
<tr class="memdesc:ac89a4e0a261185c9ed1c716d007c97c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">addTriangleToTriangulation add a triangle inside the vector of triangles. Once added the other internal structures are setted.  <a href="#ac89a4e0a261185c9ed1c716d007c97c2">More...</a><br /></td></tr>
<tr class="separator:ac89a4e0a261185c9ed1c716d007c97c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b3d30daa7889e830aae836cb5cc243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a34b3d30daa7889e830aae836cb5cc243">updateAdjacencies</a> (<a class="el" href="classDagNode.html">DagNode</a> *father, <a class="el" href="classDagNode.html">DagNode</a> *child, <a class="el" href="classDagNode.html">DagNode</a> *nodeOfFirstBrother, <a class="el" href="classDagNode.html">DagNode</a> *nodeOfSecondBrother)</td></tr>
<tr class="memdesc:a34b3d30daa7889e830aae836cb5cc243"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateAdjacencies is used in the incremental step, in makeSplits, to update the adjacencies of the triangles generated by the insertion of the new point. Given the pointer to the father, all its adjacencies are taken. Once an adjacency is found, the update process is stopped. At the end the brothers of the created node are inserted between the adjacencies.  <a href="#a34b3d30daa7889e830aae836cb5cc243">More...</a><br /></td></tr>
<tr class="separator:a34b3d30daa7889e830aae836cb5cc243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60424bc156930d5b9700f8288fb3cc96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a60424bc156930d5b9700f8288fb3cc96">updateAdjacenciesOnBrothers</a> (<a class="el" href="classDagNode.html">DagNode</a> *adjacent, <a class="el" href="classDagNode.html">DagNode</a> *splittedBrother)</td></tr>
<tr class="memdesc:a60424bc156930d5b9700f8288fb3cc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateAdjacenciesOnBrothers is used in the incremental step, in the makeSplits function, to update the adjacencies of the triangles that were adiacent to the split node.  <a href="#a60424bc156930d5b9700f8288fb3cc96">More...</a><br /></td></tr>
<tr class="separator:a60424bc156930d5b9700f8288fb3cc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4c863ce9fa1d105e2b5d2dcec7d3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a49d4c863ce9fa1d105e2b5d2dcec7d3c">updateAdjacenciesOnEdgeFlip</a> (<a class="el" href="classDagNode.html">DagNode</a> *father_1, <a class="el" href="classDagNode.html">DagNode</a> *father_2, <a class="el" href="classDagNode.html">DagNode</a> *child, <a class="el" href="classDagNode.html">DagNode</a> *brotherNode)</td></tr>
<tr class="memdesc:a49d4c863ce9fa1d105e2b5d2dcec7d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateAdjacenciesOnEdgeFlip is used in legalizeEdge to update the adjacencies of the triangles generated due to the edge flip. Considering that the triangles generated in the edge flip, share two different fathers, they can inherit the adjacencies from one of them. Naturally also the adjacencies of the triangles adjacent to the father are updated with the new nodes created.  <a href="#a49d4c863ce9fa1d105e2b5d2dcec7d3c">More...</a><br /></td></tr>
<tr class="separator:a49d4c863ce9fa1d105e2b5d2dcec7d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba49c3a9a71f8c8a789c025b8b1aafe6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#aba49c3a9a71f8c8a789c025b8b1aafe6">isPointInNode</a> (<a class="el" href="classDagNode.html">DagNode</a> *&amp;currentNode, const cg3::Point2Dd &amp;point) const</td></tr>
<tr class="memdesc:aba49c3a9a71f8c8a789c025b8b1aafe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">isPointInNode check if a point is lying in the triangle inside the current dag node  <a href="#aba49c3a9a71f8c8a789c025b8b1aafe6">More...</a><br /></td></tr>
<tr class="separator:aba49c3a9a71f8c8a789c025b8b1aafe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8371bf6493a9866b29a8fe896fb345c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#ae8371bf6493a9866b29a8fe896fb345c">makeSplits</a> (<a class="el" href="classDagNode.html">DagNode</a> *currentNode, const cg3::Point2Dd &amp;newPoint)</td></tr>
<tr class="memdesc:ae8371bf6493a9866b29a8fe896fb345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">makeSplits manages, given the current node and the new point to be inserted in the triangulation, the incremental step. Create three triangles using the new point and the vertices of the triangle to which the node refers. Once created, the triangles are inserted into the vector of triangles and the three relative nodes are created in the structure of the DAG. Once the structures are updated, the adjacencies of each new triangle are also updated, and the adjacencies of the split triangle are updated too.  <a href="#ae8371bf6493a9866b29a8fe896fb345c">More...</a><br /></td></tr>
<tr class="separator:ae8371bf6493a9866b29a8fe896fb345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddea00b836f3c30e15dd375954b67d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a7ddea00b836f3c30e15dd375954b67d2">addPointToTriangulation</a> (const cg3::Point2Dd &amp;newPoint)</td></tr>
<tr class="memdesc:a7ddea00b836f3c30e15dd375954b67d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">addPointToTriangulation is the method that permit to add a point in triangulation and calls all the related method in order to correctly manage the insertion process. Given a point, the function searches in which node of the lying. Once arrived at a leaf (the node containing the point), the leaf flag of the corresponding triangle is setted to false. The split function (makeSplits) is called in order to manage the incremental step of the algorithm. Once the children are created, the legalizeEdge function is called on each of them. At the end it will have updated our structure with the addition of the input point provided.  <a href="#a7ddea00b836f3c30e15dd375954b67d2">More...</a><br /></td></tr>
<tr class="separator:a7ddea00b836f3c30e15dd375954b67d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f6c359c7ebb3ed89cbba567e3d9e7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#a42f6c359c7ebb3ed89cbba567e3d9e7c">legalizeEdge</a> (<a class="el" href="classDagNode.html">DagNode</a> *node, size_t lowerBrotherIndex)</td></tr>
<tr class="memdesc:a42f6c359c7ebb3ed89cbba567e3d9e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">legalizeEdge has the task of managing illegal edges, the node to be checked is given in input together with a support parameter that corresponds to the smallest index among the brothers of the node to be controlled (this to avoid unnecessary checks). Considering the adjacent triangle, once its opposite point is found, it checks if this point is inside the vertex of the triangle created with the new point (the new point of the triangulation is always inserted as v1). If it is inside, then it is considered as an illegal edge, two triangles are created and all the structures are updated, considering that this time the children due to edge flip will be shared by both the current node (node) and its adjacent (adjacentNode). Once everything is updated, the recursive call is made on both children generated by the edge flip.  <a href="#a42f6c359c7ebb3ed89cbba567e3d9e7c">More...</a><br /></td></tr>
<tr class="separator:a42f6c359c7ebb3ed89cbba567e3d9e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0929cd320b67201acc734e425ba1505"><td class="memItemLeft" align="right" valign="top"><a id="ab0929cd320b67201acc734e425ba1505"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDelaunayTriangulation.html#ab0929cd320b67201acc734e425ba1505">clearDelaunayTriangulation</a> ()</td></tr>
<tr class="memdesc:ab0929cd320b67201acc734e425ba1505"><td class="mdescLeft">&#160;</td><td class="mdescRight">clearDelaunayTriangulation clear all the data structures of the triangulation. <br /></td></tr>
<tr class="separator:ab0929cd320b67201acc734e425ba1505"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0d7037cf5f5b644da9e5c2f05be935b2"><td class="memItemLeft" align="right" valign="top"><a id="a0d7037cf5f5b644da9e5c2f05be935b2"></a>
std::vector&lt; <a class="el" href="classTriangle.html">Triangle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_delauneyTriangles</b></td></tr>
<tr class="separator:a0d7037cf5f5b644da9e5c2f05be935b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8a29e099e2b5baa010a19970f751a9"><td class="memItemLeft" align="right" valign="top"><a id="a7c8a29e099e2b5baa010a19970f751a9"></a>
<a class="el" href="classDagNode.html">DagNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_dag</b></td></tr>
<tr class="separator:a7c8a29e099e2b5baa010a19970f751a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a521540379462db66a675bfb8e9ab44"><td class="memItemLeft" align="right" valign="top"><a id="a1a521540379462db66a675bfb8e9ab44"></a>
std::vector&lt; <a class="el" href="classDagNode.html">DagNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_allNodeCollection</b></td></tr>
<tr class="separator:a1a521540379462db66a675bfb8e9ab44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that manage the Delaunay Triangulation. The aim of this class is to build and fill all the data structures that rappresenting the triangulation. This class contains a vector of triangles that collect all that triangles made by splits; a dag node pointer used to build the DAG structure starting from the root (the bounding triangle); a vector of dagNode pointer that collect all the created pointer of the DAG (this is made to manage the cancellation of the dag and the construction of the voronoi diagram) </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7899c4090d9c578b0b92df9a9ae4ecaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7899c4090d9c578b0b92df9a9ae4ecaf">&#9670;&nbsp;</a></span>DelaunayTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DelaunayTriangulation::DelaunayTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>boundingTriangle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using the bounding triangle's reference. Once the triangle is pushed inside the triangles vector, its index is used to instantiate the dag root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundingTriangle</td><td>the reference of the bounding triangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ddea00b836f3c30e15dd375954b67d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddea00b836f3c30e15dd375954b67d2">&#9670;&nbsp;</a></span>addPointToTriangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DelaunayTriangulation::addPointToTriangulation </td>
          <td>(</td>
          <td class="paramtype">const cg3::Point2Dd &amp;&#160;</td>
          <td class="paramname"><em>newPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>addPointToTriangulation is the method that permit to add a point in triangulation and calls all the related method in order to correctly manage the insertion process. Given a point, the function searches in which node of the lying. Once arrived at a leaf (the node containing the point), the leaf flag of the corresponding triangle is setted to false. The split function (makeSplits) is called in order to manage the incremental step of the algorithm. Once the children are created, the legalizeEdge function is called on each of them. At the end it will have updated our structure with the addition of the input point provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newPoint</td><td>- the reference of the newPoint to add to the triangulation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac89a4e0a261185c9ed1c716d007c97c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89a4e0a261185c9ed1c716d007c97c2">&#9670;&nbsp;</a></span>addTriangleToTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DelaunayTriangulation::addTriangleToTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>newTriangle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>addTriangleToTriangulation add a triangle inside the vector of triangles. Once added the other internal structures are setted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>reference of the new <a class="el" href="classTriangle.html" title="Class representing a 2D Triangle. The triangle is rappresented by three vertices. The vertices order ...">Triangle</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a299f5ae7d5bbce0902ff8e05453ada94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299f5ae7d5bbce0902ff8e05453ada94">&#9670;&nbsp;</a></span>getAllDagNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classDagNode.html">DagNode</a> * &gt; &amp; DelaunayTriangulation::getAllDagNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getAllDagNodes get a reference to the vector of DAG nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vector of DAG nodes. </dd></dl>

</div>
</div>
<a id="a51d03a00c3df3a39981740142fb6d160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d03a00c3df3a39981740142fb6d160">&#9670;&nbsp;</a></span>getChildContainsPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDagNode.html">DagNode</a> * DelaunayTriangulation::getChildContainsPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cg3::Point2Dd &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getChildContainsPoint, given the current node and the new point to be inserted in the triangulation, return the children that cointains the point. scrolling through the list of children, it is checked which contains the node and is then returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>the pointer to the node that store the triangle's index that contains the new point </td></tr>
    <tr><td class="paramname">newPoint</td><td>the reference of the new point to insert in the triangulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next pointer of the DAG structure that contains the point </dd></dl>

</div>
</div>
<a id="ae3063d43c2871b7d2e610c16d8d30d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3063d43c2871b7d2e610c16d8d30d84">&#9670;&nbsp;</a></span>getDAG()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDagNode.html">DagNode</a> * DelaunayTriangulation::getDAG </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getDAG get the pointer to the dag root </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the dag root </dd></dl>

</div>
</div>
<a id="ae5f5d0fe187dd2709b3673af78ec738c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f5d0fe187dd2709b3673af78ec738c">&#9670;&nbsp;</a></span>getLeaves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classTriangle.html">Triangle</a> &gt; DelaunayTriangulation::getLeaves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getLeaves get the vector of triangles leaves. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of triangles </dd></dl>

</div>
</div>
<a id="a1c7cb250302b491e765c9de4b5c0f0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7cb250302b491e765c9de4b5c0f0d5">&#9670;&nbsp;</a></span>getOppositePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cg3::Point2Dd DelaunayTriangulation::getOppositePoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>currentTriangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>adjacentTriangle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getOppositePoint get the point opposite the triangle under consideration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentTriangle</td><td>is the pointer to the node under consideration. </td></tr>
    <tr><td class="paramname">adjacentTriangle</td><td>is the pointer to the node adjacent to currentTriangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the point opposite the triangle under consideration. </dd></dl>

</div>
</div>
<a id="a52b0689002927ddaecf48dab2b485037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b0689002927ddaecf48dab2b485037">&#9670;&nbsp;</a></span>getTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classTriangle.html">Triangle</a> &gt; &amp; DelaunayTriangulation::getTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getTrianles get the reference to the vector of triangles </p>
<dl class="section return"><dt>Returns</dt><dd>the reference of the vector of triangles </dd></dl>

</div>
</div>
<a id="aba49c3a9a71f8c8a789c025b8b1aafe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba49c3a9a71f8c8a789c025b8b1aafe6">&#9670;&nbsp;</a></span>isPointInNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DelaunayTriangulation::isPointInNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cg3::Point2Dd &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>isPointInNode check if a point is lying in the triangle inside the current dag node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>- the reference of the newPoint to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point lies in the node's triangle, false otherwise </dd></dl>

</div>
</div>
<a id="a42f6c359c7ebb3ed89cbba567e3d9e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f6c359c7ebb3ed89cbba567e3d9e7c">&#9670;&nbsp;</a></span>legalizeEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DelaunayTriangulation::legalizeEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lowerBrotherIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>legalizeEdge has the task of managing illegal edges, the node to be checked is given in input together with a support parameter that corresponds to the smallest index among the brothers of the node to be controlled (this to avoid unnecessary checks). Considering the adjacent triangle, once its opposite point is found, it checks if this point is inside the vertex of the triangle created with the new point (the new point of the triangulation is always inserted as v1). If it is inside, then it is considered as an illegal edge, two triangles are created and all the structures are updated, considering that this time the children due to edge flip will be shared by both the current node (node) and its adjacent (adjacentNode). Once everything is updated, the recursive call is made on both children generated by the edge flip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the pointer to the node that store the triangle's index created before. </td></tr>
    <tr><td class="paramname">lowerBrotherIndex</td><td>support parameter to avoid to check the brothers of the triangles created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8371bf6493a9866b29a8fe896fb345c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8371bf6493a9866b29a8fe896fb345c">&#9670;&nbsp;</a></span>makeSplits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DelaunayTriangulation::makeSplits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cg3::Point2Dd &amp;&#160;</td>
          <td class="paramname"><em>newPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>makeSplits manages, given the current node and the new point to be inserted in the triangulation, the incremental step. Create three triangles using the new point and the vertices of the triangle to which the node refers. Once created, the triangles are inserted into the vector of triangles and the three relative nodes are created in the structure of the DAG. Once the structures are updated, the adjacencies of each new triangle are also updated, and the adjacencies of the split triangle are updated too. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>the pointer to the node that store the triangle's index that contains the new point </td></tr>
    <tr><td class="paramname">newPoint</td><td>the reference of the new point to insert in the triangulation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34b3d30daa7889e830aae836cb5cc243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b3d30daa7889e830aae836cb5cc243">&#9670;&nbsp;</a></span>updateAdjacencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DelaunayTriangulation::updateAdjacencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>father</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>nodeOfFirstBrother</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>nodeOfSecondBrother</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updateAdjacencies is used in the incremental step, in makeSplits, to update the adjacencies of the triangles generated by the insertion of the new point. Given the pointer to the father, all its adjacencies are taken. Once an adjacency is found, the update process is stopped. At the end the brothers of the created node are inserted between the adjacencies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">father</td><td>is the pointer to the node that has been splitted. </td></tr>
    <tr><td class="paramname">child</td><td>is the pointer to one of the node that was created before to which adjacencies will be updated. </td></tr>
    <tr><td class="paramname">nodeOfFirstBrother</td><td>is the pointer to one of the brothers generated before. </td></tr>
    <tr><td class="paramname">nodeOfSecondBrother</td><td>is the pointer to one of the brothers generated before. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60424bc156930d5b9700f8288fb3cc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60424bc156930d5b9700f8288fb3cc96">&#9670;&nbsp;</a></span>updateAdjacenciesOnBrothers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DelaunayTriangulation::updateAdjacenciesOnBrothers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>adjacent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>splittedBrother</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updateAdjacenciesOnBrothers is used in the incremental step, in the makeSplits function, to update the adjacencies of the triangles that were adiacent to the split node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacent</td><td>is the pointer to the node that was adjacent to the one splitted. </td></tr>
    <tr><td class="paramname">splittedBrother</td><td>is the pointer to the splitted node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d4c863ce9fa1d105e2b5d2dcec7d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d4c863ce9fa1d105e2b5d2dcec7d3c">&#9670;&nbsp;</a></span>updateAdjacenciesOnEdgeFlip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DelaunayTriangulation::updateAdjacenciesOnEdgeFlip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>father_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>father_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDagNode.html">DagNode</a> *&#160;</td>
          <td class="paramname"><em>brotherNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updateAdjacenciesOnEdgeFlip is used in legalizeEdge to update the adjacencies of the triangles generated due to the edge flip. Considering that the triangles generated in the edge flip, share two different fathers, they can inherit the adjacencies from one of them. Naturally also the adjacencies of the triangles adjacent to the father are updated with the new nodes created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">father_1</td><td>is the pointer to one of the node that was involved in the edge flip. </td></tr>
    <tr><td class="paramname">father_2</td><td>is the pointer to one of the node that was involved in the edge flip. </td></tr>
    <tr><td class="paramname">child</td><td>is the pointer to one of the nodes created by the edge flip and to which adjacencies will be updated. </td></tr>
    <tr><td class="paramname">brotherNode</td><td>is the pointer to the other node created by the edge flip. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/jarvis/as2-project-GiacomoMeloni/GAS_2019_Delaunay/algorithms/<a class="el" href="delaunaytriangulation_8h_source.html">delaunaytriangulation.h</a></li>
<li>/home/jarvis/as2-project-GiacomoMeloni/GAS_2019_Delaunay/algorithms/delaunaytriangulation.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
